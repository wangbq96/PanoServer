#  How to design APP User Authentication System

> Chinese Version: [APP用户认证系统的设计](https://wangboquan.coding.me/blog/2017/03/09/APP%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/)

Website applications generally use **Session** to store and verify user information, while using **Token** on mobile is more common. There is little difference between them. Token is more like a simple custom session. The main function of the Session is to maintain session information, while the Token is only used for identity authentication of user who login. So using Token on App is easier and more secure than using Session.

## HTTP Basic Authentication
**HTTP Basic authentication** (BA) implementation is the simplest technique for enforcing access controls to web resources. In BA, "[username]:[password]" is merely encoded with Base64 and sent to the server in the header Authorization of the http request. If the username and password are incorrect, the server will return 401. Here we use header Authorization to pass the token information.

## Implementation

```java
// token entity
public class Token {
    private int userId;
    private String token;
    public Token(int userId, String token) {
        this.userId = userId;
        this.token = token;
    }
    public int getUserId() {
        return userId;
    }
    public void setUserId(int userId) {
        this.userId = userId;
    }
    public String getToken() {
        return token;
    }
    public void setToken(String token) {
        this.token = token;
    }
}
```

In this project, we use Redis to store user_id and token. Redis is a in-memory database of Key-Value structure. The mapping table maintained by it will be faster than traditional database. Here, spring-Data-Redis is used to perform basic operations on Token.

The Token generated by the server is generally a random non-repeating string. According to the security requirements of the application, it will be time-stamped (by time to determine whether the token is stolen) or url signature (by requesting the address to determine whether the token is stolen). In this project, for the convenience of demonstration, only user_id is used as the username, and token is used as the password to use BA.

```java
public interface TokenRepository  {
    String createToken(int userId);
    boolean checkToken(int userId, String userToken);
    void deleteToken(int userId);
}
```

```java
@Repository
public class RedisTokenRepository implements TokenRepository {
    @Autowired
    private RedisTemplate<Object, Object> redisTemplate;
    @Override
    public String createToken(int userId) {
        //使用uuid作为源token
        String token = UUID.randomUUID().toString().replace("-", "");
        //存储到redis并设置过期时间
        redis.boundValueOps(userId).set(token, Constants.TOKEN_EXPIRES_HOUR, TimeUnit.HOURS);
        redisTemplate.boundValueOps(userId).set(token);
        return token;
    }
    @Override
    public boolean checkToken(int userId, String userToken) {
        String token = (String) redisTemplate.boundValueOps(userId).get();
        if (token == null || !token.equals(userToken)) {
            return false;
        } else {
            //If the verification is successful, the user has performed a valid operation to extend the expiration time of the token.
            redis.boundValueOps(model.getUserId()).expire(Constants.TOKEN_EXPIRES_HOUR, TimeUnit.HOURS);
            return true;
        }
    }
    @Override
    public void deleteToken(int userId) {
        redisTemplate.delete(userId);
    }
}
```

This is done using Spring's interceptor, which checks if the method corresponding to each request requires authentication.

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Authorization {
}
```

```java
@Component
public class AuthorizationInterceptor extends HandlerInterceptorAdapter {
    @Autowired
    private TokenRepository tokenRepository;
    public boolean preHandle(HttpServletRequest request,
                             HttpServletResponse response,
                             Object handler) throws Exception {
        //如果不是映射到方法直接通过
        if (!(handler instanceof HandlerMethod)) {
            return true;
        }
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        Method method = handlerMethod.getMethod();
        //有注解
        if (method.getAnnotation(Authorization.class) != null) {
            String authorization = request.getHeader("authorization");
            //标准basic auth，使用BASE64加密
            String userIdAndToken=new String(new BASE64Decoder().decodeBuffer(authorization.split(" ")[1]));
            if(userIdAndToken.split(":").length<2){
                response.setStatus(HttpServletResponse.SC_OK);
                response.getWriter().println(new ErrorMessage("UnauthorizedException").toString());
                return false;
            }
            int userId=Integer.parseInt(userIdAndToken.split(":")[0]);
            String token=userIdAndToken.split(":")[1];
            if (tokenRepository.checkToken(userId, token)){
                return true;
            } else {
                response.setStatus(HttpServletResponse.SC_OK);
                response.getWriter().println(new ErrorMessage("UnauthorizedException").toString());
                return false;
            }
        } else {
            return true;
        }
    }
}
```

# How to design Timeline

> Chinese Version: [Timeline的推(push)模式和拉(pull)模式](https://wangboquan.coding.me/blog/2017/03/09/Timeline%E7%9A%84%E6%8E%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8B%89%E6%A8%A1%E5%BC%8F/)

## The features of Timeline
Although there are various timelines, they all have these three features in common:

* Everyone's timeline is unique to the individual. 
* Consists of a series of items arranged in chronological order.
* There are many different sources for entries in Timeline.

Its first feature is the value of its existence: the timeline unique to each user is the timeline he cares most. This also means that the cost of storing timeline is proportional to the amount of users.

The second feature means that it is time-sensitive, users don't care about older entries, so the length of timeline doesn't need to grow indefinitely over time. For most timeline of Internet products, hundreds of items are enough; another strategy is Truncate by time. A limited amount of entries makes it easier to estimate the cost of storing feeds and can lead to better performance.

In addition, since the user only cares about newer or unread entries, the timeline read and write ratio is roughly 1:1. When there are fewer active users, the write operation may even be more than a read operation.

## Push and Pull model
Its third feature is the reason why it is complicated, which also led to its implementation divided into two types of models:

* Pull model: When calculating the timeline, get the latest entries from various sources and then aggregate them.

* Push model: When an item is generated, it is pushed to the timeline of its follower.

The pull model is easy to implement and has less storage cost (no need to save a separate piece of data for each user), but because it is calculated in real time when acquired, the read performance is poor.

The storage cost of the push model is relatively large, and the cost of push is large when there are many followers, but the read performance is good, and real-time update and message push are easier to implement.

Of course, these two models can be combined according to different sources. Those sources with more followers are obtained by pull model, and the rest are still pushed to the timeline of the follower. As long as these sources are not many (usually they are also cached), the impact on read performance is not too large, but greatly reduces the push cost.

## The Implementation of Pull model

Create two database tables as follow.

`item(id, poster_id, content, status, created_at)`

`friendship(id, follower_id, followee_id, created_at)`

and we can implement pull model using one simple sql.

```sql
SELECT *
FROM item
WHERE poster_id IN (SELECT followee_id
                    FROM friendship
                    WHERE follower_id = user_id)
AND status = public
ORDER BY created_at
DESC LIMIT 0, 50;
```

However, the shortcomings are quite obvious. If you focus on 1000 users, the second statement will query 1000 times, then combine the results and then sort them. This is very slow, unless there are few users.

And if you want to improve, it seems that you can only use the cache. As the number of users grows, both the item and the friendship table need to be split. One possible solution is to divide the item table by poster_id, and also to divide the recent items by time (when the cache fails, you can speed up the query); the friendship table may need to separate the follower_id and followee_id separately. 

## The Implementation of Pull model

Create three database tables as follow.

`item(id, poster_id, content, status, created_at)`
`friendship(id, follower_id, followee_id, created_at)`
`timeline(id, user_id, item_id, created_at)`

When the user posts an item, get all the followees from friendship, and insert this item into their timeline. This operation actually allows for delays and failures, so just plug it into the task queue.

To get timeline, you can query directly by user_id:

```sql
SELECT item_id FROM timeline
WHERE user_id = user_id ORDER BY created_at DESC LIMIT 0, 50;
```

Then get the details from the item table based on item_id. As time goes on, the timeline table also needs to be split.

Compared to the pull model, pushing the model requires two more things:

* When Item is deleted or hidden by the publisher, it needs to be removed from the timeline of himself and all followees.

* When unfollowing, you need to delete all items that were sent from followee from the follower's timeline.

For the first thing, you can find all followers and do the deletion:

```sql
DELETE FROM timeline WHERE user_id IN (user_ids) AND item_id = item_id;
```

It is not such easy for the second thing to do it. It is possible to traverse all the items in the timeline. After all, a user's timeline is limited in length, just an O(n) operation.

A better approach is to add a redundant field poster_id to the timeline table and add an index (user_id, poster_id) to delete it like this:

```sql
DELETE FROM timeline WHERE user_id = user_id AND poster_id = poster_id;
```
